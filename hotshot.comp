component hotshot "Hotshot Board Driver";
license "GPL";

// plasmac requires floating-point
function _ fp;
// function calibrate fp;
function sensors fp;

// option extra_setup;
option extra_cleanup;

pin out bit arc_ok;          // wire to plasmac.arc-ok-in
pin out float arc_voltage;   // wire to plasmac.arc-voltage-in
pin out bit torch_breakaway; // wire to plasmac.breakaway
pin in bit torch_on;         // wire to plasmac.torch-on
pin in bit ohmic_enable;     // wire to plasmac.ohmic-enable
pin out bit ohmic_probe;     // wire to plasmac.ohmic-probe

pin in u32 axis_x_chip;
pin in u32 axis_x_motor;
pin in u32 axis_x_pitch;
pin in u32 axis_x_teeth;

pin in u32 axis_yl_chip;
pin in u32 axis_yl_motor;
pin in u32 axis_yl_pitch;
pin in u32 axis_yl_teeth;

pin in u32 axis_yr_chip;
pin in u32 axis_yr_motor;
pin in u32 axis_yr_pitch;
pin in u32 axis_yr_teeth;

pin in u32 axis_z_chip;
pin in u32 axis_z_motor;
pin in u32 axis_z_pitch;
pin in u32 axis_z_teeth;

pin in bit axis_x_enable;
pin in bit axis_yl_enable;
pin in bit axis_yr_enable;
pin in bit axis_z_enable;

pin in float axis_x_position_cmd;  // commanded position
pin out float axis_x_position_fb;  // actual position
pin in float axis_yl_position_cmd; // commanded position
pin out float axis_yl_position_fb; // actual position
pin in float axis_yr_position_cmd; // commanded position
pin out float axis_yr_position_fb; // actual position
pin in float axis_z_position_cmd;  // commanded position
pin out float axis_z_position_fb;  // actual position

// In machine units (i.e. mm or inch) per second
pin in float axis_x_max_velocity_cmd;
pin in float axis_yl_max_velocity_cmd;
pin in float axis_yr_max_velocity_cmd;
pin in float axis_z_max_velocity_cmd;

pin out float axis_x_velocity_fb;
pin out float axis_yl_velocity_fb;
pin out float axis_yr_velocity_fb;
pin out float axis_z_velocity_fb;

pin out s32 axis_x_tmc_velocity_fb;
pin out s32 axis_yl_tmc_velocity_fb;
pin out s32 axis_yr_tmc_velocity_fb;
pin out s32 axis_z_tmc_velocity_fb;

pin out s32 axis_x_tmc_position_fb;
pin out s32 axis_yl_tmc_position_fb;
pin out s32 axis_yr_tmc_position_fb;
pin out s32 axis_z_tmc_position_fb;

pin in float axis_x_max_acceleration_cmd;
pin in float axis_yl_max_acceleration_cmd;
pin in float axis_yr_max_acceleration_cmd;
pin in float axis_z_max_acceleration_cmd;

pin out u32 axis_x_tmc_max_acceleration_fb;
pin out u32 axis_yl_tmc_max_acceleration_fb;
pin out u32 axis_yr_tmc_max_acceleration_fb;
pin out u32 axis_z_tmc_max_acceleration_fb;

pin in bit axis_x_is_homing;
pin in bit axis_yl_is_homing;
pin in bit axis_yr_is_homing;
pin in bit axis_z_is_homing;

pin out bit axis_x_home_sw;
pin out bit axis_yl_home_sw;
pin out bit axis_yr_home_sw;
pin out bit axis_z_home_sw;

pin out bit axis_x_neg_limit_sw;
pin out bit axis_yl_neg_limit_sw;
pin out bit axis_yr_neg_limit_sw;
pin out bit axis_z_neg_limit_sw;

pin in u32 axis_x_tmc_sg_thresh_cmd;
pin in u32 axis_yl_tmc_sg_thresh_cmd;
pin in u32 axis_yr_tmc_sg_thresh_cmd;
pin in u32 axis_z_tmc_sg_thresh_cmd;

pin in bit axis_x_tmc_sg_stop_cmd;
pin in bit axis_yl_tmc_sg_stop_cmd;
pin in bit axis_yr_tmc_sg_stop_cmd;
pin in bit axis_z_tmc_sg_stop_cmd;

pin out bit axis_x_sg_stop_fb;
pin out bit axis_yl_sg_stop_fb;
pin out bit axis_yr_sg_stop_fb;
pin out bit axis_z_sg_stop_fb;

pin in u32 axis_x_tmc_run_current_cmd;
pin in u32 axis_yl_tmc_run_current_cmd;
pin in u32 axis_yr_tmc_run_current_cmd;
pin in u32 axis_z_tmc_run_current_cmd;

pin in u32 axis_x_tmc_hold_current_cmd;
pin in u32 axis_yl_tmc_hold_current_cmd;
pin in u32 axis_yr_tmc_hold_current_cmd;
pin in u32 axis_z_tmc_hold_current_cmd;

pin in u32 axis_x_microsteps_cmd;
pin in u32 axis_yl_microsteps_cmd;
pin in u32 axis_yr_microsteps_cmd;
pin in u32 axis_z_microsteps_cmd;

pin in u32 axis_x_tmc_cs_thresh_cmd;
pin in u32 axis_yl_tmc_cs_thresh_cmd;
pin in u32 axis_yr_tmc_cs_thresh_cmd;
pin in u32 axis_z_tmc_cs_thresh_cmd;

pin out u32 axis_x_tmc_microstep_resolution_fb;
pin out u32 axis_yl_tmc_microstep_resolution_fb;
pin out u32 axis_yr_tmc_microstep_resolution_fb;
pin out u32 axis_z_tmc_microstep_resolution_fb;

pin out s32 axis_x_tmc_motor_load_fb;
pin out s32 axis_yl_tmc_motor_load_fb;
pin out s32 axis_yr_tmc_motor_load_fb;
pin out s32 axis_z_tmc_motor_load_fb;

pin out u32 axis_x_tmc_motor_current_fb;
pin out u32 axis_yl_tmc_motor_current_fb;
pin out u32 axis_yr_tmc_motor_current_fb;
pin out u32 axis_z_tmc_motor_current_fb;

pin out bit axis_x_tmc_motor_stall_fb;
pin out bit axis_yl_tmc_motor_stall_fb;
pin out bit axis_yr_tmc_motor_stall_fb;
pin out bit axis_z_tmc_motor_stall_fb;

pin out bit axis_x_tmc_motor_standstill_fb;
pin out bit axis_yl_tmc_motor_standstill_fb;
pin out bit axis_yr_tmc_motor_standstill_fb;
pin out bit axis_z_tmc_motor_standstill_fb;

pin out bit axis_x_tmc_motor_full_stepping_fb;
pin out bit axis_yl_tmc_motor_full_stepping_fb;
pin out bit axis_yr_tmc_motor_full_stepping_fb;
pin out bit axis_z_tmc_motor_full_stepping_fb;

pin out bit axis_x_tmc_motor_overtemp_warning_fb;
pin out bit axis_yl_tmc_motor_overtemp_warning_fb;
pin out bit axis_yr_tmc_motor_overtemp_warning_fb;
pin out bit axis_z_tmc_motor_overtemp_warning_fb;

pin out bit axis_x_tmc_motor_overtemp_alarm_fb;
pin out bit axis_yl_tmc_motor_overtemp_alarm_fb;
pin out bit axis_yr_tmc_motor_overtemp_alarm_fb;
pin out bit axis_z_tmc_motor_overtemp_alarm_fb;

pin out bit axis_x_tmc_position_reached_fb;
pin out bit axis_yl_tmc_position_reached_fb;
pin out bit axis_yr_tmc_position_reached_fb;
pin out bit axis_z_tmc_position_reached_fb;

pin out bit axis_x_tmc_t_zerowait_active_fb;
pin out bit axis_yl_tmc_t_zerowait_active_fb;
pin out bit axis_yr_tmc_t_zerowait_active_fb;
pin out bit axis_z_tmc_t_zerowait_active_fb;

pin out bit axis_x_tmc_velocity_reached_fb;
pin out bit axis_yl_tmc_velocity_reached_fb;
pin out bit axis_yr_tmc_velocity_reached_fb;
pin out bit axis_z_tmc_velocity_reached_fb;

pin out float axis_x_tmc_max_velocity_fb;
pin out float axis_yl_tmc_max_velocity_fb;
pin out float axis_yr_tmc_max_velocity_fb;
pin out float axis_z_tmc_max_velocity_fb;

pin out bit estop-fb;
pin in bit estop-cmd;
pin out bit abort-fb;

;;

#include <stdlib.h>
#include <stdio.h>
// #include <errno.h>
// #include <fcntl.h>
// #include <sys/mman.h>
// #include <string.h>
// #include <time.h>
// #include <unistd.h>
// #include <math.h>
// #include <sys/types.h>
#include <rtapi.h>
#include "tmc/ic/TMC5041/TMC5041.h"
#include "bcm2835.h"
#include "hotshot.h"
#include "tmc5041.h"

// ============================================================================
// bcm2835.c

#include "bcm2835.c"

// bcm2835.c
// ============================================================================

#include "rpi.c"

// ============================================================================
// TMC5041 support

#include "tmc5041.c"

// TMC5041 support
// ============================================================================

// ============================================================================
// Main application

int64_t mm_to_microsteps(uint32_t microstep_per_mm, float mm)
{
    return mm * microstep_per_mm;
}

uint32_t microsteps_per_mm(uint32_t fullsteps_per_rev, float linear_mm_per_rev, uint32_t microsteps)
{
    return (fullsteps_per_rev * microsteps) / linear_mm_per_rev;
}


spi_status_t follow(joint_t * motor)
{
    // XTARGET: Target position for ramp mode
    // Calculate target position and velocity
    // Implicitly round to lower since were converting from float to int
    int32 xtarget = (*motor->position_cmd) * motor->microstep_per_mm;
    spi_status_t spi_status = tmc5041_set_register_XTARGET(motor, xtarget);

    int64_t xactual_value = tmc5041_get_register_XACTUAL(motor);
    spi_status.xactual_mm = (float)xactual_value / (float)motor->microstep_per_mm;

    return spi_status;
}

float thc_voltage(uint8_t chip, float V_ref)
{
    //
    // Read from ADC
    // Protocol start bit (S), sgl/diff (D), odd/sign (C), MSBF (M)
    //  S = 1
    //  D = 1 ; 0=diff, 1= Single ended (i.e. 2 channel) mode
    //  C = 0; if D=0, then odd/sign, if D=1, then 0 or 1 for channel number
    //  M = 1
    // Message = { 0000000S, DCM00000, 00000000 }
    // Final byte of zeros is so we get an 3 total bytes back from ADC
    char send_data[3] = {0b00000001, 0b10000000, 0b00000000};
    bcm2835_aux_spi_transfern(send_data, 3);
    // Intrepret ADC response
    // Get sensor value
    uint16_t value = 0x00;
    // We need only data from last 2 bytes.
    // And there we can discard last two bits to get 10 bit value
    // as MCP3002 resolution is 10bits
    //
    // 15 = 0000 1111 with & operation makes sure that we have all data from XXXX DDDD and nothing more.
    value = send_data[1] & 15;
    // Move to left to make room for next piece of data.
    value = value << 6; // 000D DDDD << 6 == 0DDD DD00 0000
    // Now we get the last of data from byte 3, discarding last two bits
    value = value + (send_data[2] >> 2);
    // DDDD DDXXX >> 2 == 00DD DDDD
    // 0DDD DD00 0000 + 00DD DDDD == 0DDD DDDD DDDD
    // Convert to voltage
    // Voltage = ( V_ref * value ) / 1024
    float voltage = (V_ref * value) / 1024;

    // Assumes 50:1 voltage divider
    return voltage * 50;
}

bool was_all_homed = 0;

bool get_home_switch_state(joint_t * motor, bool axis_is_homing) {
    if (axis_is_homing) {
        ramp_stat_register_t reg = tmc5041_get_register_RAMP_STAT(motor);
        return reg.status_sg;
    }
    return FALSE;
}

bool get_neg_limit_switch_state(joint_t * motor, float axis_max_velocity_cmd) {
    if (axis_max_velocity_cmd < 0) {
        ramp_stat_register_t reg = tmc5041_get_register_RAMP_STAT(motor);
        return reg.status_sg;
    }
    return FALSE;
}

#include "hotshot_init.c"

// Main application
// ============================================================================

// ============================================================================
// LinuxCNC HAL Module

void handle_joint(joint_t * motor) {

    if (*motor->is_enabled) {

        #ifdef DEBUG
        rtapi_print("joint x is enabled. chip=%d motor=%d pitch=%d teeth=%d\n", 
            motor->chip, motor->motor, motor->pitch, motor->teeth);
        #endif

        start_spi_conversation(motor->chip);

        // Check switches
        //
        // Note: Reading RAMP_STAT clears sg_stop
        ramp_stat_register_t ramp_stat = tmc5041_get_register_RAMP_STAT(motor);
        // Note: status_sg and event_stop_sg appear to be the same
        // axis_x_sg_stop_fb = ramp_stat.event_stop_sg;
        *motor->sg_stop_fb = ramp_stat.status_sg;
        // TODO
        // axis_x_tmc_position_reached_fb = ramp_stat.position_reached;
        // axis_x_tmc_t_zerowait_active_fb = ramp_stat.t_zerowait_active;
        // axis_x_tmc_velocity_reached_fb = ramp_stat.velocity_reached;
                
        #ifdef DEBUG
        rtapi_print("ramp_stat axis_x_sg_stop_fb %d \n", (*motor->sg_stop_fb));
        #endif

        // Handle StallGuard state
        //
        if (*motor->sg_stop_fb) {
            // StallGuard has been triggered

            #ifdef DEBUG
            rtapi_print("SG triggered sg_stop_cmd=%d sg_thresh_cmd=%d\n", 
                motor->tmc_sg_stop_cmd, motor->tmc_sg_thresh_cmd);
            #endif

            // TODO shut off torch
            // TODO stop motion controller or motor will twitch every time we read RAMP_STAT

            if (motor->is_homing) {
                // We are homing and we have hit a Stallguard stop event, so trigger home switch

                #ifdef DEBUG
                rtapi_print("Setting home\n");
                #endif

                motor->home_sw = set_home(motor);
            } else {
                // We've hit a Stallguard stop, but we're not homing, so trigger breakaway

                #ifdef DEBUG
                rtapi_print("Setting breakaway\n");
                #endif

                // TODO Add `torch_breakaway = set_breakaway(&motors[0])1 that should immediately stop motor
                *motor->torch_breakaway_fb = TRUE;
                // TODO "breakaway" for the x axis should indicate negative limit switch is triggered
                // There is currently no negative limit switch for X and YL/YR
            }             
        } else {
            // No active StallGuard switches, so move motor and reset all switches

            #ifdef DEBUG
            rtapi_print("Moving motor to %f\n", (*motor->position_cmd));
            #endif

            // Move motor
            //
            spi_status_t spi_status = follow(motor);

            #ifdef DEBUG
            rtapi_print("Followed position to %f\n", spi_status.xactual_mm);
            #endif

            *motor->position_fb = spi_status.xactual_mm;

            #ifdef DEBUG
            rtapi_print("position_fb is %f\n", *motor->position_fb);
            #endif

            *motor->tmc_position_fb = tmc5041_get_register_XACTUAL(motor);

            #ifdef DEBUG
            rtapi_print("Motor actual position now %f\n", *motor->position_fb);
            #endif

            // Ensure switches aren't triggered
            //
            motor->home_sw = FALSE;
            // FIXME
            *motor->torch_breakaway_fb = FALSE;

            #ifdef DEBUG
            rtapi_print("Finished resetting switches\n");
            #endif
        }

        #ifdef DEBUG
        rtapi_print("Get velocity\n");
        #endif

        // Get velocity
        //
        *motor->tmc_velocity_fb = tmc5041_get_register_VACTUAL(motor);
        float vactual_mm = (float)(*motor->tmc_velocity_fb) / (float)motor->microstep_per_mm;
        *motor->velocity_fb = vactual_mm;
       
        #ifdef DEBUG
        rtapi_print("vactual_mm is %f\n", vactual_mm);
        rtapi_print("Get driver state\n");
        #endif

        // Get driver state
        // 
        drv_status_register_t drv_status = tmc5041_get_register_DRV_STATUS(motor);
        *motor->tmc_motor_standstill_fb = drv_status.standstill;
        *motor->tmc_motor_full_stepping_fb = drv_status.full_stepping;
        *motor->tmc_motor_overtemp_warning_fb = drv_status.overtemp_warning;
        *motor->tmc_motor_overtemp_alarm_fb = drv_status.overtemp_alarm;
        *motor->tmc_motor_load_fb = drv_status.sg_result;
        *motor->tmc_motor_current_fb = drv_status.cs_actual;
        *motor->tmc_motor_stall_fb = drv_status.sg_status;

        #ifdef DEBUG
        rtapi_print("vactual_mm is %f\n", vactual_mm);
        rtapi_print("Get chopper state\n");
        #endif

        // Get chopper state
        //
        chopconf_register_t chopconf = tmc5041_get_register_CHOPCONF(motor);
        *motor->tmc_microstep_resolution_fb = chopconf.mres;

        #ifdef DEBUG
        rtapi_print("Done handling joint\n");
        #endif

        end_spi_conversation();
    } else {
        // Joint is not enabled in LinuxCNC

        // Cut power to motor
        // Can only do this when we config_motor inside motor->is_enabled condition
        // TODO reset_motor(&motors[0]);
        motor->is_on = FALSE;

        // Clear torch breakaway
        // TODO we should really do this when we transition from unenabled to enabled power
        *motor->torch_breakaway_fb = FALSE;
    }
}

// main function
FUNCTION(_)
{
    // Set up motors exactly once.
    if (needs_setup) {

        // X
        #undef axis_x_enable
        #undef axis_x_is_homing
        #undef axis_x_position_cmd
        #undef axis_x_tmc_sg_stop_cmd
        #undef axis_x_tmc_sg_thresh_cmd
        uint32_t axis_x_microstep_per_mm = microsteps_per_mm(200, axis_x_pitch * axis_x_teeth, axis_x_microsteps_cmd);
        motors[0] = (joint_t) {
            .chip                   = axis_x_chip,
            .motor                  = axis_x_motor,
            .pitch                  = axis_x_pitch,
            .teeth                  = axis_x_teeth,
            .is_enabled             = __comp_inst->axis_x_enable,
            .is_homing              = __comp_inst->axis_x_is_homing,
            .position_cmd           = __comp_inst->axis_x_position_cmd,
            .position_fb            = &axis_x_position_fb,
            .max_velocity_cmd       = axis_x_max_velocity_cmd,
            .velocity_fb            = &axis_x_velocity_fb,
            .max_acceleration_cmd   = axis_x_max_acceleration_cmd,
            .microsteps_cmd         = axis_x_microsteps_cmd,
            .mm_per_rev             = axis_x_pitch * axis_x_teeth,
            .microstep_per_mm       = axis_x_microstep_per_mm,
            .tmc_run_current_cmd    = axis_x_tmc_run_current_cmd,
            .tmc_hold_current_cmd   = axis_x_tmc_hold_current_cmd,
            .tmc_sg_stop_cmd        = __comp_inst->axis_x_tmc_sg_stop_cmd,
            .tmc_sg_thresh_cmd      = __comp_inst->axis_x_tmc_sg_thresh_cmd,
            .tmc_mres                           = microsteps_to_tmc_mres(axis_x_microsteps_cmd),
            .tmc_cs_thresh                      = axis_x_tmc_cs_thresh_cmd,
            .tmc_max_velocity_fb                = &axis_x_tmc_max_velocity_fb,
            .tmc_max_acceleration_fb            = &axis_x_tmc_max_acceleration_fb,
            .sg_stop_fb                         = &axis_x_sg_stop_fb,
            .home_sw_fb                         = &axis_x_home_sw,
            .tmc_position_fb                    = &axis_x_tmc_position_fb,
            .tmc_velocity_fb                    = &axis_x_tmc_velocity_fb,
            .tmc_motor_standstill_fb            = &axis_x_tmc_motor_standstill_fb,
            .tmc_motor_full_stepping_fb         = &axis_x_tmc_motor_full_stepping_fb,
            .tmc_motor_overtemp_warning_fb      = &axis_x_tmc_motor_overtemp_warning_fb,
            .tmc_motor_overtemp_alarm_fb        = &axis_x_tmc_motor_overtemp_alarm_fb,
            .tmc_motor_load_fb                  = &axis_x_tmc_motor_load_fb,
            .tmc_motor_current_fb               = &axis_x_tmc_motor_current_fb,
            .tmc_motor_stall_fb                 = &axis_x_tmc_motor_stall_fb,
            .tmc_microstep_resolution_fb        = &axis_x_tmc_microstep_resolution_fb,
            // TODO move to sensors() function
            .torch_breakaway_fb     = &torch_breakaway,
        };
        *motors[0].tmc_max_velocity_fb = (float)fabs(axis_x_max_velocity_cmd) * axis_x_microstep_per_mm;
        *motors[0].tmc_max_acceleration_fb = mm_to_microsteps(axis_x_microstep_per_mm, axis_x_max_acceleration_cmd);

        // YL
        #undef axis_yl_enable
        #undef axis_yl_is_homing
        #undef axis_yl_position_cmd
        #undef axis_yl_tmc_sg_stop_cmd
        #undef axis_yl_tmc_sg_thresh_cmd
        uint32_t axis_yl_microstep_per_mm = microsteps_per_mm(200, axis_yl_pitch * axis_yl_teeth, axis_yl_microsteps_cmd);
        motors[1] = (joint_t) {
            .chip                   = axis_yl_chip,
            .motor                  = axis_yl_motor,
            .pitch                  = axis_yl_pitch,
            .teeth                  = axis_yl_teeth,
            .is_enabled             = __comp_inst->axis_yl_enable,
            .is_homing              = __comp_inst->axis_yl_is_homing,
            .position_cmd           = __comp_inst->axis_yl_position_cmd,
            .position_fb            = &axis_yl_position_fb,
            .max_velocity_cmd       = axis_yl_max_velocity_cmd,
            .velocity_fb            = &axis_yl_velocity_fb,
            .max_acceleration_cmd   = axis_yl_max_acceleration_cmd,
            .microsteps_cmd         = axis_yl_microsteps_cmd,
            .mm_per_rev             = axis_yl_pitch * axis_yl_teeth,
            .microstep_per_mm       = axis_yl_microstep_per_mm,
            .tmc_run_current_cmd    = axis_yl_tmc_run_current_cmd,
            .tmc_hold_current_cmd   = axis_yl_tmc_hold_current_cmd,
            .tmc_sg_stop_cmd        = __comp_inst->axis_yl_tmc_sg_stop_cmd,
            .tmc_sg_thresh_cmd      = __comp_inst->axis_yl_tmc_sg_thresh_cmd,
            .tmc_mres               = microsteps_to_tmc_mres(axis_yl_microsteps_cmd),
            .tmc_cs_thresh                      = axis_yl_tmc_cs_thresh_cmd,
            .tmc_max_velocity_fb                = &axis_yl_tmc_max_velocity_fb,
            .tmc_max_acceleration_fb            = &axis_yl_tmc_max_acceleration_fb,
            .sg_stop_fb                         = &axis_yl_sg_stop_fb,
            .home_sw_fb                         = &axis_yl_home_sw,
            .tmc_position_fb                    = &axis_yl_tmc_position_fb,
            .tmc_velocity_fb                    = &axis_yl_tmc_velocity_fb,
            .tmc_motor_standstill_fb            = &axis_yl_tmc_motor_standstill_fb,
            .tmc_motor_full_stepping_fb         = &axis_yl_tmc_motor_full_stepping_fb,
            .tmc_motor_overtemp_warning_fb      = &axis_yl_tmc_motor_overtemp_warning_fb,
            .tmc_motor_overtemp_alarm_fb        = &axis_yl_tmc_motor_overtemp_alarm_fb,
            .tmc_motor_load_fb                  = &axis_yl_tmc_motor_load_fb,
            .tmc_motor_current_fb               = &axis_yl_tmc_motor_current_fb,
            .tmc_motor_stall_fb                 = &axis_yl_tmc_motor_stall_fb,
            .tmc_microstep_resolution_fb        = &axis_yl_tmc_microstep_resolution_fb,
            // TODO move to sensors() function
            .torch_breakaway_fb     = &torch_breakaway,
        };
        *motors[1].tmc_max_velocity_fb = (float)fabs(axis_yl_max_velocity_cmd) * axis_yl_microstep_per_mm;
        *motors[1].tmc_max_acceleration_fb = mm_to_microsteps(axis_yl_microstep_per_mm, axis_yl_max_acceleration_cmd);

        // YR
        #undef axis_yr_enable
        #undef axis_yr_is_homing
        #undef axis_yr_position_cmd
        #undef axis_yr_tmc_sg_stop_cmd
        #undef axis_yr_tmc_sg_thresh_cmd
        uint32_t axis_yr_microstep_per_mm = microsteps_per_mm(200, axis_yr_pitch * axis_yr_teeth, axis_yr_microsteps_cmd);
        motors[2] = (joint_t) {
            .chip                   = axis_yr_chip,
            .motor                  = axis_yr_motor,
            .pitch                  = axis_yr_pitch,
            .teeth                  = axis_yr_teeth,
            .is_enabled             = __comp_inst->axis_yr_enable,
            .is_homing              = __comp_inst->axis_yr_is_homing,
            .position_cmd           = __comp_inst->axis_yr_position_cmd,
            .position_fb            = &axis_yr_position_fb,
            .max_velocity_cmd       = axis_yr_max_velocity_cmd,
            .velocity_fb            = &axis_yr_velocity_fb,
            .max_acceleration_cmd   = axis_yr_max_acceleration_cmd,
            .microsteps_cmd         = axis_yr_microsteps_cmd,
            .mm_per_rev             = axis_yr_pitch * axis_yr_teeth,
            .microstep_per_mm       = axis_yr_microstep_per_mm,
            .tmc_run_current_cmd    = axis_yr_tmc_run_current_cmd,
            .tmc_hold_current_cmd   = axis_yr_tmc_hold_current_cmd,
            .tmc_sg_stop_cmd        = __comp_inst->axis_yr_tmc_sg_stop_cmd,
            .tmc_sg_thresh_cmd      = __comp_inst->axis_yr_tmc_sg_thresh_cmd,
            .tmc_mres                           = microsteps_to_tmc_mres(axis_yr_microsteps_cmd),
            .tmc_cs_thresh                      = axis_yr_tmc_cs_thresh_cmd,
            .tmc_max_velocity_fb                = &axis_yr_tmc_max_velocity_fb,
            .tmc_max_acceleration_fb            = &axis_yr_tmc_max_acceleration_fb,
            .sg_stop_fb                         = &axis_yr_sg_stop_fb,
            .home_sw_fb                         = &axis_yr_home_sw,
            .tmc_position_fb                    = &axis_yr_tmc_position_fb,
            .tmc_velocity_fb                    = &axis_yr_tmc_velocity_fb,
            .tmc_motor_standstill_fb            = &axis_yr_tmc_motor_standstill_fb,
            .tmc_motor_full_stepping_fb         = &axis_yr_tmc_motor_full_stepping_fb,
            .tmc_motor_overtemp_warning_fb      = &axis_yr_tmc_motor_overtemp_warning_fb,
            .tmc_motor_overtemp_alarm_fb        = &axis_yr_tmc_motor_overtemp_alarm_fb,
            .tmc_motor_load_fb                  = &axis_yr_tmc_motor_load_fb,
            .tmc_motor_current_fb               = &axis_yr_tmc_motor_current_fb,
            .tmc_motor_stall_fb                 = &axis_yr_tmc_motor_stall_fb,
            .tmc_microstep_resolution_fb        = &axis_yr_tmc_microstep_resolution_fb,
            // TODO move to sensors() function
            .torch_breakaway_fb     = &torch_breakaway,
        };
        *motors[2].tmc_max_velocity_fb = (float)fabs(axis_yr_max_velocity_cmd) * axis_yr_microstep_per_mm;
        *motors[2].tmc_max_acceleration_fb = mm_to_microsteps(axis_yr_microstep_per_mm, axis_yr_max_acceleration_cmd);

        // Z
        #undef axis_z_enable
        #undef axis_z_is_homing
        #undef axis_z_position_cmd
        #undef axis_z_tmc_sg_stop_cmd
        #undef axis_z_tmc_sg_thresh_cmd
        uint32_t axis_z_microstep_per_mm = microsteps_per_mm(200, axis_z_pitch * axis_z_teeth, axis_z_microsteps_cmd);
        motors[3] = (joint_t) {
            .chip                   = axis_z_chip,
            .motor                  = axis_z_motor,
            .pitch                  = axis_z_pitch,
            .teeth                  = axis_z_teeth,
            .is_enabled             = __comp_inst->axis_z_enable,
            .is_homing              = __comp_inst->axis_z_is_homing,
            .position_cmd           = __comp_inst->axis_z_position_cmd,
            .position_fb            = &axis_z_position_fb,
            .max_velocity_cmd       = axis_z_max_velocity_cmd,
            .velocity_fb            = &axis_z_velocity_fb,
            .max_acceleration_cmd   = axis_z_max_acceleration_cmd,
            .microsteps_cmd         = axis_z_microsteps_cmd,
            .mm_per_rev             = axis_z_pitch * axis_z_teeth,
            .microstep_per_mm       = axis_z_microstep_per_mm,
            .tmc_run_current_cmd    = axis_z_tmc_run_current_cmd,
            .tmc_hold_current_cmd   = axis_z_tmc_hold_current_cmd,
            .tmc_sg_stop_cmd        = __comp_inst->axis_z_tmc_sg_stop_cmd,
            .tmc_sg_thresh_cmd      = __comp_inst->axis_z_tmc_sg_thresh_cmd,
            .tmc_mres               = microsteps_to_tmc_mres(axis_z_microsteps_cmd),
            .tmc_cs_thresh                      = axis_z_tmc_cs_thresh_cmd,
            .tmc_max_velocity_fb                = &axis_z_tmc_max_velocity_fb,
            .tmc_max_acceleration_fb            = &axis_z_tmc_max_acceleration_fb,
            .sg_stop_fb                         = &axis_z_sg_stop_fb,
            .home_sw_fb                         = &axis_z_home_sw,
            .tmc_position_fb                    = &axis_z_tmc_position_fb,
            .tmc_velocity_fb                    = &axis_z_tmc_velocity_fb,
            .tmc_motor_standstill_fb            = &axis_z_tmc_motor_standstill_fb,
            .tmc_motor_full_stepping_fb         = &axis_z_tmc_motor_full_stepping_fb,
            .tmc_motor_overtemp_warning_fb      = &axis_z_tmc_motor_overtemp_warning_fb,
            .tmc_motor_overtemp_alarm_fb        = &axis_z_tmc_motor_overtemp_alarm_fb,
            .tmc_motor_load_fb                  = &axis_z_tmc_motor_load_fb,
            .tmc_motor_current_fb               = &axis_z_tmc_motor_current_fb,
            .tmc_motor_stall_fb                 = &axis_z_tmc_motor_stall_fb,
            .tmc_microstep_resolution_fb        = &axis_z_tmc_microstep_resolution_fb,
            // TODO move to sensors() function
            .torch_breakaway_fb     = &torch_breakaway,
        };
        *motors[3].tmc_max_velocity_fb = (float)fabs(axis_z_max_velocity_cmd) * microsteps_per_mm(200, axis_z_pitch * axis_z_teeth, axis_z_microsteps_cmd);
        *motors[3].tmc_max_acceleration_fb = mm_to_microsteps(axis_z_microstep_per_mm, axis_z_max_acceleration_cmd);

        #ifdef DEBUG
        rtapi_print("Invoking setup_once\n");
        #endif

        needs_setup = setup_once(motors, MOTOR_COUNT);
    }

    // TODO TMC-API Call this function once per cycle for each IC
    // tmc5041_periodicJob(TMC5041TypeDef *tmc5041, uint32_t tick)
    // tmc5041_periodicJob(TMC5041TypeDef *tmc5041, uint32_t tick)

    handle_joint(&motors[0]);
    handle_joint(&motors[1]);
    handle_joint(&motors[2]);
    handle_joint(&motors[3]);

}

FUNCTION(sensors) {

    start_spi_conversation(BCM2835_SPI_CS1);

    // TODO go into estop mode on estop-cmd?

    // TODO maybe set abort-fb
    abort_fb = FALSE;

    // Read in arc voltage and set arc_voltage pin
    float V_ref = 5;
    arc_voltage = thc_voltage(BCM2835_SPI_CS1, V_ref);
    // TODO implmement moving average? https://forums.raspberrypi.com/viewtopic.php?t=40248
    //      (new result) = (previous result)*(1 - ratio) + (new sample) * (ratio)
    //      using a ratio of 0.025
    end_spi_conversation();

    // Read in arc ok switch state and set arc_ok bin bit
    //  plasmac.arc-ok-in bit in
    //    external arc ok input signal [mode 1 & mode 2]
    uint8_t arc_ok_level = bcm2835_gpio_lev(PIN_ARC_OK);
    if (arc_ok_level == HIGH)
    {
        arc_ok = TRUE;
    }
    else
    {
        arc_ok = FALSE;
    }

    // Removed in favor of Stallguard based breakaway
    //
    // Read in breakaway switch state and set breakaway pin bit
    //  plasmac.breakaway bit in
    //      torch breakaway switch (optional, see float_switch)
    // uint8_t torch_breakaway_level = bcm2835_gpio_lev(PIN_TORCH_BREAKAWAY);
    // if (torch_breakaway_level == LOW)
    // {
    //     torch_breakaway = TRUE;
    // }
    // else
    // {
    //     torch_breakaway = FALSE;
    // }

    // Read in ohmic probe contact state and set ohmic_probe pin bit
    //  plasmac.ohmic-probe bit in
    //      ohmic probe input
    uint8_t ohmic_probe_level = bcm2835_gpio_lev(PIN_OHMIC_PROBE);
    if (ohmic_probe_level == HIGH)
    {
        ohmic_probe = TRUE;
    }
    else
    {
        ohmic_probe = FALSE;
    }

    // Read in ohmic probe contact state and set ohmic_probe pin bit
    // estop is wired fail safe, i.e. active low.
    // However, PlasmaC expects FALSE to indicate active estop
    uint8_t estop_fb_level = bcm2835_gpio_lev(PIN_ESTOP);
    if (estop_fb_level == HIGH)
    {
        estop_fb = TRUE;
    }
    else
    {
        estop_fb = FALSE;
    }

    // Read in ohmic_enable pin and enable/disable ohmic sensor relay
    //  plasmac.ohmic-enable bit out
    //      on only while probing
    if (ohmic_enable)
    {
        bcm2835_gpio_set(PIN_OHMIC_ENABLE);
    }
    else
    {
        bcm2835_gpio_clr(PIN_OHMIC_ENABLE);
    }

    // Read in torch_on pin bit and enable/disable torch fire relay
    //  plasmac.torch-on bit out
    //      turn torch on, connect to your torch on input
    if (torch_on)
    {
        bcm2835_gpio_set(PIN_TORCH_ON);
    }
    else
    {
        bcm2835_gpio_clr(PIN_TORCH_ON);
    }
}

EXTRA_CLEANUP()
{
    teardown_tmc5041(motors);
   
    teardown_spi0();
    teardown_spi1();

    // Close the library, deallocating any allocated memory and closing /dev/mem
    bcm2835_close();
}

// HAL Module
// ============================================================================

// ============================================================================
// Test

// FUNCTION(calibrate)                                                                                                                                              
// {
//     float vtarget_mm_per_sec    = axis_x_max_velocity_cmd;
//     float xtarget_mm            = 0.0;   // absolute position along an axis
//     start_spi_conversation(motors[0]);
//     // Start movement
//     //
//     tmc5041_set_register_RAMPMODE(motors[0], 1); // velocity mode
//     move_motor(motors[0], xtarget_mm);
//     // Get calibration info
//     //
//     int64_t xactual = tmc5041_get_register_XACTUAL(motors[0]);
//     float xactualmm = xactual_mm(motors[0]);
//     float vmax = mm_to_microsteps(motors[0].microstep_per_mm, axis_x_max_velocity_cmd);
//     ramp_stat_register_t ramp_stat = tmc5041_get_register_RAMP_STAT(motors[0]);
//     bool get_home_switch = get_home_switch_state(motors[0], 0);
//     bool get_neg_limit_switch = get_neg_limit_switch_state(motors[0], vtarget_mm_per_sec);
//     drv_status_register_t drv_status = tmc5041_get_register_DRV_STATUS(motors[0]);
//     uint16_t sg_result = drv_status.sg_result;
//     uint8_t cs_actual = drv_status.cs_actual;
//     bool sg_status = drv_status.sg_status;
//     axis_x_home_sw = get_home_switch;
//     axis_x_neg_limit_sw = get_neg_limit_switch;
//     axis_x_position_fb = xactualmm;
//     axis_x_load = sg_result;
//     axis_x_current = cs_actual;
//     axis_x_stall = sg_status;
//     // And echo it
//     //
//     rtapi_print("hotshot (%d:%d): Calibrate\n", motors[0].chip, motors[0].motor);
//     rtapi_print("    axis_x_max_velocity_cmd=%f, vmax=%f, axis_x_max_acceleration_cmd=%f\n", 
//         axis_x_max_velocity_cmd, vmax, axis_x_max_acceleration_cmd);
//     rtapi_print("    xactual_mm=%f, xactual=%d\n", 
//         xactualmm, xactual);
//     rtapi_print("    axis_x_load=%d, axis_x_current=%d, axis_x_stall=%d\n", 
//         sg_result, cs_actual, sg_status);
//     rtapi_print("    event_stop_sg=%d\n", ramp_stat.event_stop_sg);
//     rtapi_print("    axis_x_home_sw=%d, axis_x_neg_limit_sw=%d\n", 
//         get_home_switch, get_neg_limit_switch);
//     end_spi_conversation();
// }

// Test
// ============================================================================
